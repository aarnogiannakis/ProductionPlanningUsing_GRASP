# <42137 Optimization using Metaheuristics -- Assignment 02>
# GRASP for PlastOut Planning
#
# This script outlines the implementation of a Greedy Randomized Adaptive Search Procedure (GRASP) 
# for solving the PlantOut Planning problem. The algorithm aims to maximize the revenue while considering
# the cost savings from pairing orders on the same production line.
#
# Key aspects of this algorithm include:
#   Neighborhood Operator: Utilizes swap moves between order lines to explore the solution space.
#   Termination Criteria: The algorithm terminates based on a predefined time limit, ensuring timely execution.
#   Step Criterion: Employs the "Best Improvement" strategy for selecting the next move, focusing on the most beneficial swap.
#   Cost: Operates with a revenue matrix for individual orders and a cost-saving matrix for order pairs, derived from an input file.
#   Initialization: Implements a Greedy Randomized Cnstruction heuristic for generating an initial solution.
#   Reactive GRASP: Adjusts the greediness level (α) dynamically, balancing exploitation and exploration to improve solution quality over iterations.
#*****************************************************************************************************
using Random

# Read an instance of the GRASP for PlantOut Planning--> Input: filename = path + filename of the instance
function read_instance(filename)
    f = open(filename)
    name = readline(f) # name of the instance
    size = parse(Int32,readline(f)) # number of order
    LB = parse(Int32,readline(f)) # best known revenue
    rev = parse.(Int32,split(readline(f)))# revenue for including an order
    rev_pair = zeros(Int32,size,size) # pairwise revenues
    for i in 1:size-1
        data = parse.(Int32,split(readline(f)))
        j=i+1
        for d in data
            rev_pair[i,j]=d
            rev_pair[j,i]=d
            j+=1
        end
    end
    readline(f)
    k = parse(Int32,readline(f)) # number of production lines
    H = parse(Int32,readline(f)) # planning horizon
    p = parse.(Int32,split(readline(f))) # production times
    close(f)
    return name, size, LB ,rev, rev_pair, k, H, p
end
#*****************************************************************************************************


#*****************************************************************************************************
# Definition of ProductionPlanningSolver
# A struct that encapsulates the essential elements for addressing the Production Planning Problem within a Reactive GRASP framework. 
# It includes information about individual product revenues, pairwise product cost savings when produced on the same line, production times, 
# the number of production lines (k), the planning horizon (H), and the total number of products (size).
struct ProductionPlanningSolver
    rev::Array{Int32,1}
    rev_pair::Array{Int32,2}
    p::Array{Int32,1}
    k::Int32
    H::Int32
    size::Int32
    ProductionPlanningSolver(rev, rev_pair, p, k, H, size) = new(rev, rev_pair, p, k, H, size)
end

# Definition of ProductionPlanningSolution
# A mutable struct that symbolizes a feasible solution for the Production Planning Problem. 
# It maintains an assignment of products to production lines, the total objective value of the solution, 
# and the production times utilized on each line. This structure facilitates the evaluation of solution quality 
# and compliance with production constraints.
mutable struct ProductionPlanningSolution
    # we represent a solution as an array of arrays, each sub-array represents a production line
    assignment::Array{Array{Int32,1},1}
    # placeholder for the objective value
    objective::Int32
    # total production time for each line
    production_times::Array{Int32,1}

    # Default constructor for creating an empty solution setup
    ProductionPlanningSolution(k, H) = new([Int32[] for _ in 1:k], 0, zeros(Int32, k) .+ H)
end
#*****************************************************************************************************


#*****************************************************************************************************
# Calculates the total revenue for a production planning solution.
# Arguments:
#      solution: A ProductionPlanningSolution object containing the assignment of orders to production lines.
#      solver: A ProductionPlanningSolver object containing problem-specific data such as revenues and cost savings.
# Returns:
#      The total revenue generated by the solution, considering both individual order revenues and additional revenues from pairing orders on the same production line.
#*****************************************************************************************************
function calculate_objective(solution::ProductionPlanningSolution, solver::ProductionPlanningSolver)
    # Initialize total revenue to zero
    total_revenue = 0
    # Iterate over each production line
    for line in 1:solver.k
        # Iterate over each order assigned to the current line
        for order in solution.assignment[line]
            # Add the revenue for producing the order
            total_revenue += solver.rev[order]
            # Calculate additional revenues from pairing this order with other orders on the same line
            for other_order in solution.assignment[line]
                # Ensure each pair is only considered once (avoid double counting)
                if order < other_order
                    total_revenue += solver.rev_pair[order, other_order]
                end
            end
        end
    end
    # Update the solution's objective value
    solution.objective = total_revenue
    # Return the calculated total revenue
    return total_revenue
end
#*****************************************************************************************************


#*****************************************************************************************************
# Ensures feasibility of solution
# Arguments:
#      solution: A ProductionPlanningSolution object containing the assignment of orders to production lines.
#      solver: A ProductionPlanningSolver object containing problem-specific data such as revenues and cost savings.
# Returns:
#      Boolean depending if the solution is valid or not.
#*****************************************************************************************************
function check_constraints(solution::ProductionPlanningSolution, solver::ProductionPlanningSolver)
    # Aggregate all orders across all production lines into a single list.
    all_orders = [order for line in solution.assignment for order in line]
    # Check if all orders in that aggegated list are unique
    if length(unique(all_orders)) != length(all_orders)
        # This means that at least one order has been assigned to more that one production line.
        return false
    end

    for line in 1:solver.k
        # sum up the individual production times of each order on the line
        line_time = sum(solver.p[order] for order in solution.assignment[line])
        # Check if the total production time of each line does not exceed the planning horizon
        if line_time > solver.H
            # "The total manufacturing time of a production line cannot exceed the planning horizon."
            return false
        end
    end

    # "Solution respects all constraints."
    return true
end
#*****************************************************************************************************


#*****************************************************************************************************
# Implements a Randomized version of the greedy construction heuristic for production planning.
# Arguments:
#      solver: A ProductionPlanningSolver object containing problem-specific data such as revenues and cost savings.
#      α: A threshold parameter.
#
# Returns:
#      An initial solution.
#*****************************************************************************************************
function GreedyRandomizedConstruction(solver::ProductionPlanningSolver, α::Float64)
    # Initialize an empty solution
    sol = ProductionPlanningSolution(solver.k, solver.H)
    # Flags to check if an order is assigned -- 1st constraint
    order_assigned = zeros(Bool, solver.size)

    # While not all orders are assigned, and we have feasible options to assign
    while sum(order_assigned) < solver.size
        # List of candidate orders with their corresponding lines and incremental revenues
        candidates = []
        candidate_revenues = []

        # Evaluate the incremental revenue of adding each non-assigned order to each production line
        for order in 1:solver.size
            # if order is not assigned
            if !order_assigned[order]
                # for each production line 
                for line in 1:solver.k
                    # Only consider inserting it if production time is sufficient on the line -- 2nd contstaint 
                    if sum(solver.p[sol.assignment[line]]) + solver.p[order] <= solver.H

                        # Calculate the incremental revenue for this order on this line
                        incremental_revenue = solver.rev[order]
                        # Calculate the incremental revenue from the cost savings
                        for assigned_order in sol.assignment[line]
                            incremental_revenue += solver.rev_pair[order, assigned_order]
                        end
                        # Adds a tuple to the candidates list for each potential order-line pairing
                        push!(candidates, (order=order, line=line))
                        # Do the same and bring in the incremental revenue 
                        push!(candidate_revenues, incremental_revenue)
                    end
                end
            end
        end

        # Construction of the Restricted Candidate List (RCL)
        RCL = []
        if !isempty(candidate_revenues)
            cMin = minimum(candidate_revenues)
            cMax = maximum(candidate_revenues)

            for i in eachindex(candidate_revenues)
                if candidate_revenues[i] >= (cMax - α * (cMax - cMin))
                    push!(RCL, candidates[i])
                end
            end
        end

        # If RCL is empty, break the loop as no more feasible assignments can be made
        if isempty(RCL)
            break
        end

        # Select an order-line pair at random from RCL
        selected_pair = RCL[rand(1:length(RCL))]
        # This line adds the selected order to the solution's assignment for the specified production line. 
        push!(sol.assignment[selected_pair.line], selected_pair.order)
        # This line marks the selected order as assigned by setting its corresponding entry in the order_assigned array to true.
        order_assigned[selected_pair.order] = true
    end

    # Calculate the objective value of the solution
    sol.objective = calculate_objective(sol, solver)
    return sol
end
#*****************************************************************************************************


#*****************************************************************************************************
# Swaps two elements in the solution's assignment
function swap!(sol::ProductionPlanningSolution, line1::Int, order1_idx::Int, line2::Int, order2_idx::Int)
    sol.assignment[line1][order1_idx], sol.assignment[line2][order2_idx] = sol.assignment[line2][order2_idx], sol.assignment[line1][order1_idx]
end
#*****************************************************************************************************


#*****************************************************************************************************
# Calculate the objective delta for a swap between two orders in the solution
# Arguments:
#      solver: A ProductionPlanningSolver object containing problem-specific data such as revenues and cost savings.
#      sol: A ProductionPlanningSolution object containing the assignment of orders to production lines.
#      order1_idx: The index of the first order in its production line (line1) to be swapped.
#      order2_idx: The index of the second order in its production line (line2) to be swapped.
#      line1: The production line index where the first order is currently assigned.
#      line2: The production line index where the second order is currently assigned.
# Returns:
#      The difference between the new and current objective values after attempting the swap.
#*****************************************************************************************************
function calculate_Objective_Delta(solver::ProductionPlanningSolver, sol::ProductionPlanningSolution, order1_idx::Int, order2_idx::Int, line1::Int, line2::Int)::Int
    # Perform the swap: Exchange the positions of the two selected orders between their respective production lines.
    swap!(sol, line1, order1_idx, line2, order2_idx)

    # Check if the swap results in a feasible solution, adhering to all problem constraints.
    if !check_constraints(sol, solver)
        # If the swap is not feasible (violates constraints), revert the swap and report no improvement.
        swap!(sol, line1, order1_idx, line2, order2_idx)
        return 0
    else
        # If the swap is feasible, calculate the new objective value of the solution with the swap in place.
        new_objective = calculate_objective(sol, solver)

        # Revert the swap to restore the original solution state before the swap.
        swap!(sol, line1, order1_idx, line2, order2_idx)

        # Calculate the current objective value of the original solution for comparison.
        current_objective = calculate_objective(sol, solver)

        # Return the difference in objective values (new - current) to indicate the improvement or degradation.
        return new_objective - current_objective
    end
end
#*****************************************************************************************************


#*****************************************************************************************************
# Performs a Local Search to find a local optimum by iteratively improving the current solution.
# Arguments:
#      solver: A ProductionPlanningSolver object containing problem-specific data such as revenues and cost savings.
#      sol: A ProductionPlanningSolution object containing the assignment of orders to production lines.
# Returns:
#      A local optimum solution improved from the initial solution.
#*****************************************************************************************************
function local_search!(solver::ProductionPlanningSolver, sol::ProductionPlanningSolution)
    # Flag to keep track of whether an improvement was found
    improved = true

    while improved
        # Reset improvement flag for the new iteration
        improved = false  
        # Initialize to a very negative number to ensure that any positive delta would be considered an improvement
        best_delta = -typemax(Int)  
        # Initialize best swap details
        best_swap = (0, 0, 0, 0)  # (line1, order1_idx, line2, order2_idx)

        # Iterate through all pairs of production lines and orders within those lines to evaluate potential swaps
        for line1 in 1:solver.k
            for order1_idx in 1:length(sol.assignment[line1])
                for line2 in 1:solver.k
                    for order2_idx in 1:length(sol.assignment[line2])
                        # Skip swaps within the same line or invalid indices
                        if line1 == line2 || order1_idx == order2_idx
                            continue
                        end

                        # Calculate the objective value difference (delta) if the current swap is performed
                        delta = calculate_Objective_Delta(solver, sol, order1_idx, order2_idx, line1, line2)

                        # If this is the best improvement so far, remember it
                        if delta > best_delta && delta > 0
                            best_delta = delta
                            best_swap = (line1, order1_idx, line2, order2_idx)
                            improved = true
                        end
                    end
                end
            end
        end

        if improved
            println("Improvement found with delta: ", best_delta)
            # Perform the swap that resulted in the best improvement found in this iteration
            # best_swap[1] and best_swap[3] are the indices of the production lines where the orders are currently assigned.
            # best_swap[2] and best_swap[4] are the indices of the orders within their respective production lines to be swappe
            swap!(sol, best_swap[1], best_swap[2], best_swap[3], best_swap[4])

            # Update the objective value of the solution to reflect the changes made by the best swap
            sol.objective = calculate_objective(sol, solver)

            println("New objective value after swap: ", sol.objective)
        else
            # If no improvement was found in this iteration, exit the loop
            println("No improvement found.")
        end
    end

    return sol
end
#*****************************************************************************************************


#*****************************************************************************************************
# Samples a value from an array based on a given set of probabilities
# Arguments:
#      p: An array of probabilities associated with each index.
# Returns:
#      An integer representing the selected index based on the provided probabilities.
#*****************************************************************************************************
function sampleIdx(p)
    # get a random value ∈ [0,1]
    v = rand()
    # Initialize index to start from the first element
    i = 1
    # Initialize cumulative probability with the first probability value
    P = p[i]
    
    # Iterate through probabilities until the cumulative probability exceeds the random value
    while(v>=P)
        # move to the next index
        i+=1
        # Update cumulative probability by adding the next probability value
        P +=p[i]
    end

    # Return the index where the cumulative probability first exceeds the random value
    return i
end
#*****************************************************************************************************


#*****************************************************************************************************
# Updates the running average with a new value.
# This function is useful for updating performance metrics in adaptive algorithms like Reactive GRASP.
# Arguments:
#      mean: The current running average.
#      count: The number of values already included in the running average.
#      value: The new value to be incorporated into the running average.
# Returns:
#      The updated running average incorporating the new value.
#*****************************************************************************************************
function update_average(mean, count, value)
    return mean + (value - mean)/(count+1)
end
#*****************************************************************************************************


#*****************************************************************************************************
# Performs the Reactive Greedy Randomized Adaptive Search Procedure (GRASP) for the Production Planning Problem.
# This approach dynamically adjusts the greediness/randomization level (alpha) based on past performance.
# Arguments:
#      solver: A ProductionPlanningSolver object containing problem-specific data.
#      time_limit: The time limit for the GRASP procedure.
# Returns:
#      The best solution found and the alpha value that led to the best solution.
#*****************************************************************************************************
function Reactive_GRASP(solver::ProductionPlanningSolver, time_limit::Int)
    # Initialize the best solution with the worst possible objective value
    best_solution = ProductionPlanningSolution(solver.k, solver.H)
    best_solution.objective = typemin(Int32)

    # Initialize algorithm parameters
    iterations = 1
    # Alpha value that led to the best solution
    best_alpha = 0  
    # Set of alpha values for randomization level
    Alphas = [0.1, 0.2, 0.4, 0.6, 0.8]
    # Initial probabilities for each alpha
    p = [1/length(Alphas) for _ in 1:length(Alphas)]
    # Array to store average solution quality for each alpha
    A = zeros(length(Alphas))
    # Count of selections for each alpha
    A_count = zeros(length(Alphas))
    # Quality ratio for each alpha
    q = ones(length(Alphas))
    # Sum of quality ratios, for normalization
    sum_q = length(Alphas)

    # Time tracking
    start_time = time_ns()
    elapsed_time() = (time_ns() - start_time) / 1e9

    # Main GRASP loop
    while elapsed_time() < time_limit
        # Select an alpha value based on probability distribution
        aIdx = sampleIdx(p)
        α = Alphas[aIdx]
        # Increment selection count for chosen alpha
        A_count[aIdx] += 1

        # Generate and improve solution based on selected alpha
        sol = GreedyRandomizedConstruction(solver, α)
        sol = local_search!(solver, sol)

        # Update best solution if current solution is better
        if sol.objective > best_solution.objective
            best_solution = deepcopy(sol)
            best_alpha = α
        end

        # Update performance metrics for chosen alpha
        A[aIdx] = update_average(A[aIdx], A_count[aIdx], sol.objective)
        # Remove old quality ratio from sum
        sum_q -= q[aIdx]
        # Calculate new quality ratio
        q[aIdx] = best_solution.objective / A[aIdx]
        # Add new quality ratio to sum
        sum_q += q[aIdx]

        # Update probabilities for selecting each alpha
        for i in 1:length(Alphas)
            p[i] = q[i] / sum_q
        end

        # Periodically print current best objective and associated alpha
        if iterations % 50 == 0
            println("Objective: $(best_solution.objective) Time: $(elapsed_time()) Alpha: $(Alphas[aIdx])")
        end
        iterations += 1
    end

    # Return the best solution found and the alpha value that led to it
    return best_solution, best_alpha
end
#*****************************************************************************************************


#*****************************************************************************************************
# Write the best solution to the solution file according to the guidelines.
function write_solution_to_file(file, solution)
    for orders in solution.assignment
        # Convert the orders array to a string representation
        orders_str = join(orders, " ")  # Joins the order IDs with spaces
        write(file, orders_str, "\n")  # Write each line's orders to the file, followed by a newline
    end
end
#*****************************************************************************************************


#*****************************************************************************************************
# Main function of the program
function main()
    # Check if the correct number of arguments are passed
    if length(ARGS) != 3
        println("Usage: julia s222717.jl <instance_file> <solution_file> <time_limit>")
        return
    end

    # Parse command-line arguments
    filename = ARGS[1]
    solution_file = ARGS[2]
    time_limit = parse(Int, ARGS[3])

    # Read the instance data from the file
    name, size, LB, rev, rev_pair, k, H, p = read_instance(filename)

    # Create a ProductionPlanningSolver instance with the data
    solver = ProductionPlanningSolver(rev, rev_pair, p, k, H, size)

    # Execute the Reactive GRASP algorithm to find the best solution
    best_solution, best_alpha = Reactive_GRASP(solver, time_limit)

    # Print the best solution found
    println("Best solution found with objective value: ", best_solution.objective)
    println("Best a: ", best_alpha)
    println("Best solution assignment to production lines:")
    for (line, orders) in enumerate(best_solution.assignment)
        println("Line ", line, ": ", orders)
    end

    # Write the best solution to the solution file
    open(solution_file, "w") do file
        write_solution_to_file(file, best_solution)
    end
end
#*****************************************************************************************************


#*****************************************************************************************************
# Run the main function if this script is executed as a program
if abspath(PROGRAM_FILE) == @__FILE__
    main()
end
#*****************************************************************************************************